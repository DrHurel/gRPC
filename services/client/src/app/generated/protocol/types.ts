// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.27.2
// source: protocol/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "protocol";

/** Types de base */
export interface Address {
  country: string;
  city: string;
  street: string;
  number: string;
  locationHint: string;
  gpsPosition: GPSPosition | undefined;
}

export interface Header {
  code: number;
  message: string;
}

export interface GPSPosition {
  latitude: number;
  longitude: number;
}

export interface Room {
  id: string;
  beds: number;
  basePrice: number;
  name: string;
  size: number;
}

export interface Offer {
  id: string;
  room: Room | undefined;
  availableDate: string;
  price: number;
}

export interface Customer {
  firstName: string;
  lastName: string;
  creditCard: CreditCard | undefined;
}

export interface CreditCard {
  number: string;
  expirationDate: string;
  cvv: string;
}

function createBaseAddress(): Address {
  return { country: "", city: "", street: "", number: "", locationHint: "", gpsPosition: undefined };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.country !== "") {
      writer.uint32(10).string(message.country);
    }
    if (message.city !== "") {
      writer.uint32(18).string(message.city);
    }
    if (message.street !== "") {
      writer.uint32(26).string(message.street);
    }
    if (message.number !== "") {
      writer.uint32(34).string(message.number);
    }
    if (message.locationHint !== "") {
      writer.uint32(42).string(message.locationHint);
    }
    if (message.gpsPosition !== undefined) {
      GPSPosition.encode(message.gpsPosition, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.street = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.number = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.locationHint = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gpsPosition = GPSPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      street: isSet(object.street) ? globalThis.String(object.street) : "",
      number: isSet(object.number) ? globalThis.String(object.number) : "",
      locationHint: isSet(object.locationHint) ? globalThis.String(object.locationHint) : "",
      gpsPosition: isSet(object.gpsPosition) ? GPSPosition.fromJSON(object.gpsPosition) : undefined,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.street !== "") {
      obj.street = message.street;
    }
    if (message.number !== "") {
      obj.number = message.number;
    }
    if (message.locationHint !== "") {
      obj.locationHint = message.locationHint;
    }
    if (message.gpsPosition !== undefined) {
      obj.gpsPosition = GPSPosition.toJSON(message.gpsPosition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.country = object.country ?? "";
    message.city = object.city ?? "";
    message.street = object.street ?? "";
    message.number = object.number ?? "";
    message.locationHint = object.locationHint ?? "";
    message.gpsPosition = (object.gpsPosition !== undefined && object.gpsPosition !== null)
      ? GPSPosition.fromPartial(object.gpsPosition)
      : undefined;
    return message;
  },
};

function createBaseHeader(): Header {
  return { code: 0, message: "" };
}

export const Header: MessageFns<Header> = {
  encode(message: Header, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Header {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Header {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Header): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Header>, I>>(base?: I): Header {
    return Header.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Header>, I>>(object: I): Header {
    const message = createBaseHeader();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGPSPosition(): GPSPosition {
  return { latitude: 0, longitude: 0 };
}

export const GPSPosition: MessageFns<GPSPosition> = {
  encode(message: GPSPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GPSPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGPSPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.latitude = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GPSPosition {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
    };
  },

  toJSON(message: GPSPosition): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GPSPosition>, I>>(base?: I): GPSPosition {
    return GPSPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GPSPosition>, I>>(object: I): GPSPosition {
    const message = createBaseGPSPosition();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    return message;
  },
};

function createBaseRoom(): Room {
  return { id: "", beds: 0, basePrice: 0, name: "", size: 0 };
}

export const Room: MessageFns<Room> = {
  encode(message: Room, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.beds !== 0) {
      writer.uint32(16).int32(message.beds);
    }
    if (message.basePrice !== 0) {
      writer.uint32(25).double(message.basePrice);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.size !== 0) {
      writer.uint32(40).int32(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Room {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.beds = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.basePrice = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.size = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Room {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      beds: isSet(object.beds) ? globalThis.Number(object.beds) : 0,
      basePrice: isSet(object.basePrice) ? globalThis.Number(object.basePrice) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
    };
  },

  toJSON(message: Room): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.beds !== 0) {
      obj.beds = Math.round(message.beds);
    }
    if (message.basePrice !== 0) {
      obj.basePrice = message.basePrice;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Room>, I>>(base?: I): Room {
    return Room.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Room>, I>>(object: I): Room {
    const message = createBaseRoom();
    message.id = object.id ?? "";
    message.beds = object.beds ?? 0;
    message.basePrice = object.basePrice ?? 0;
    message.name = object.name ?? "";
    message.size = object.size ?? 0;
    return message;
  },
};

function createBaseOffer(): Offer {
  return { id: "", room: undefined, availableDate: "", price: 0 };
}

export const Offer: MessageFns<Offer> = {
  encode(message: Offer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.room !== undefined) {
      Room.encode(message.room, writer.uint32(18).fork()).join();
    }
    if (message.availableDate !== "") {
      writer.uint32(26).string(message.availableDate);
    }
    if (message.price !== 0) {
      writer.uint32(33).double(message.price);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Offer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOffer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.room = Room.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.availableDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.price = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Offer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      room: isSet(object.room) ? Room.fromJSON(object.room) : undefined,
      availableDate: isSet(object.availableDate) ? globalThis.String(object.availableDate) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
    };
  },

  toJSON(message: Offer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.room !== undefined) {
      obj.room = Room.toJSON(message.room);
    }
    if (message.availableDate !== "") {
      obj.availableDate = message.availableDate;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Offer>, I>>(base?: I): Offer {
    return Offer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Offer>, I>>(object: I): Offer {
    const message = createBaseOffer();
    message.id = object.id ?? "";
    message.room = (object.room !== undefined && object.room !== null) ? Room.fromPartial(object.room) : undefined;
    message.availableDate = object.availableDate ?? "";
    message.price = object.price ?? 0;
    return message;
  },
};

function createBaseCustomer(): Customer {
  return { firstName: "", lastName: "", creditCard: undefined };
}

export const Customer: MessageFns<Customer> = {
  encode(message: Customer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstName !== "") {
      writer.uint32(10).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(18).string(message.lastName);
    }
    if (message.creditCard !== undefined) {
      CreditCard.encode(message.creditCard, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Customer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.creditCard = CreditCard.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Customer {
    return {
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      creditCard: isSet(object.creditCard) ? CreditCard.fromJSON(object.creditCard) : undefined,
    };
  },

  toJSON(message: Customer): unknown {
    const obj: any = {};
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.creditCard !== undefined) {
      obj.creditCard = CreditCard.toJSON(message.creditCard);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Customer>, I>>(base?: I): Customer {
    return Customer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Customer>, I>>(object: I): Customer {
    const message = createBaseCustomer();
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.creditCard = (object.creditCard !== undefined && object.creditCard !== null)
      ? CreditCard.fromPartial(object.creditCard)
      : undefined;
    return message;
  },
};

function createBaseCreditCard(): CreditCard {
  return { number: "", expirationDate: "", cvv: "" };
}

export const CreditCard: MessageFns<CreditCard> = {
  encode(message: CreditCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== "") {
      writer.uint32(10).string(message.number);
    }
    if (message.expirationDate !== "") {
      writer.uint32(18).string(message.expirationDate);
    }
    if (message.cvv !== "") {
      writer.uint32(26).string(message.cvv);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreditCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreditCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.number = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expirationDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cvv = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreditCard {
    return {
      number: isSet(object.number) ? globalThis.String(object.number) : "",
      expirationDate: isSet(object.expirationDate) ? globalThis.String(object.expirationDate) : "",
      cvv: isSet(object.cvv) ? globalThis.String(object.cvv) : "",
    };
  },

  toJSON(message: CreditCard): unknown {
    const obj: any = {};
    if (message.number !== "") {
      obj.number = message.number;
    }
    if (message.expirationDate !== "") {
      obj.expirationDate = message.expirationDate;
    }
    if (message.cvv !== "") {
      obj.cvv = message.cvv;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreditCard>, I>>(base?: I): CreditCard {
    return CreditCard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreditCard>, I>>(object: I): CreditCard {
    const message = createBaseCreditCard();
    message.number = object.number ?? "";
    message.expirationDate = object.expirationDate ?? "";
    message.cvv = object.cvv ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
